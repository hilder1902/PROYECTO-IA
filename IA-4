
""" CIERRA PERO ESTA MUY INCOMPLETO"""








import os
import signal
import threading
import time
import logging
import pickle
import numpy as np
import pandas as pd
import MetaTrader5 as mt5
import tensorflow as tf

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Evento de salida
exit_event = threading.Event()

def handle_exit(signum, frame):
    """Maneja Ctrl + C y marca exit_event como activo."""
    logging.info("Interrupción detectada (Ctrl + C). Cerrando el programa inmediatamente...")
    exit_event.set()
    mt5.shutdown()  # Cierra MetaTrader 5 correctamente
    os._exit(0)  # Salida forzada sin esperar

# Captura la señal Ctrl + C (SIGINT)
signal.signal(signal.SIGINT, handle_exit)

def cargar_modelo():
    """Carga el modelo desde un archivo o crea uno nuevo si no existe."""
    try:
        with open("modelo_entrenado.pkl", "rb") as f:
            modelo = pickle.load(f)
        logging.info("Modelo cargado correctamente.")
    except (FileNotFoundError, EOFError):
        logging.info("No se encontró un modelo entrenado. Creando uno nuevo...")
        modelo = tf.keras.Sequential([
            tf.keras.layers.LSTM(64, return_sequences=True, input_shape=(50, 1)),
            tf.keras.layers.LSTM(32),
            tf.keras.layers.Dense(16, activation="relu"),
            tf.keras.layers.Dense(1)
        ])
        modelo.compile(optimizer="adam", loss="mse", metrics=["mae"])
    return modelo

def obtener_datos_mt5(simbolo, timeframe, n_candles):
    """Obtiene los datos históricos desde MetaTrader 5."""
    rates = mt5.copy_rates_from_pos(simbolo, timeframe, 0, n_candles)
    if rates is None or len(rates) < n_candles:
        logging.warning(f"No se pudieron obtener suficientes datos para {simbolo}.")
        return None
    return pd.DataFrame(rates)[['close']]

def preparar_datos(df):
    """Prepara los datos para el entrenamiento del modelo."""
    X, y = [], []
    for i in range(len(df) - 51):
        X.append(df.iloc[i:i+50].values)
        y.append(df.iloc[i+50].values)
    return np.array(X), np.array(y)

def entrenar_modelo(modelo, X_train, y_train):
    """Ejecuta el entrenamiento del modelo en un hilo separado."""
    if not exit_event.is_set():
        modelo.fit(X_train, y_train, epochs=10, batch_size=32, verbose=1)

def guardar_modelo(modelo):
    """Guarda el modelo entrenado en un archivo."""
    with open("modelo_entrenado.pkl", "wb") as f:
        pickle.dump(modelo, f)
    logging.info("Modelo guardado correctamente.")

def watch_for_exit():
    """Espera a que se active exit_event y luego cierra la conexión."""
    try:
        while not exit_event.is_set():
            time.sleep(1)
    except KeyboardInterrupt:
        logging.info("Interrupción detectada en watch_for_exit. Cerrando...")
        exit_event.set()

def main():
    """Función principal que gestiona la ejecución del programa."""
    logging.info("Iniciando el programa...")
    
    if not mt5.initialize():
        logging.error("Error al inicializar MetaTrader 5")
        return
    
    modelo = cargar_modelo()
    simbolo = "EURUSDm"
    timeframe = mt5.TIMEFRAME_M1
    n_candles = 100
    
    datos = obtener_datos_mt5(simbolo, timeframe, n_candles)
    if datos is None:
        logging.error("No se pudieron obtener datos. Saliendo...")
        return
    
    X_train, y_train = preparar_datos(datos)
    
    entrenamiento_thread = threading.Thread(target=entrenar_modelo, args=(modelo, X_train, y_train))
    entrenamiento_thread.start()
    
    watch_for_exit()
    entrenamiento_thread.join()
    guardar_modelo(modelo)
    logging.info("Programa finalizado correctamente.")

if __name__ == "__main__":
    main()
