

APLIQUE REGISTRO EN TODAS LAS FUNCIONES, PARA RASTREAR POSIBLES ERRORES










".\mi_entorno_1\Scripts\Activate"

"numero de cuenta" "197115903"

"servidor" "Exness-MT5Trial11"

".\mi_entorno_1\Scripts\Activate"

import MetaTrader5 as mt5 
import logging
import time

import tensorflow as tf
from tensorflow import keras

import scipy as sp
import pandas as pd
import numpy as np
import os
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'

from sklearn.model_selection import train_test_split, TimeSeriesSplit
from sklearn.metrics import accuracy_score, mean_absolute_error
from sklearn.preprocessing import MinMaxScaler

# Definir capas de Keras
Input = tf.keras.layers.Input
LSTM = tf.keras.layers.LSTM
Dense = tf.keras.layers.Dense
Attention = tf.keras.layers.Attention
Dropout = tf.keras.layers.Dropout

# Importar modelos y optimizadores desde tf.keras
Model = tf.keras.models.Model
Sequential = tf.keras.models.Sequential
Adam = tf.keras.optimizers.Adam
EarlyStopping = tf.keras.callbacks.EarlyStopping

import optuna




















import MetaTrader5 as mt5
import pandas as pd
import time
import logging
import sys  # Para obtener el nombre de la funci贸n en ejecuci贸n

# Configuraci贸n del logging para mostrar mensajes en la consola
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def fetch_market_data(symbol, timeframe, limit=10, interval=1, continuous=False):
    function_name = sys._getframe().f_code.co_name  # Obtiene din谩micamente el nombre de la funci贸n
    logging.info(f"[{function_name}] Iniciando con symbol={symbol}, timeframe={timeframe}, limit={limit}, interval={interval}, continuous={continuous}")

    if not mt5.initialize():
        logging.error(f"[{function_name}] No se pudo inicializar MetaTrader 5.")
        return None

    try:
        if continuous:
            logging.info(f"[{function_name}] Iniciando obtenci贸n continua de datos para {symbol} cada {interval} segundos...")
            while True:
                try:
                    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, limit)
                    if rates is None:
                        logging.error(f"[{function_name}] Error al obtener datos para {symbol}: {mt5.last_error()}")
                    else:
                        df = pd.DataFrame(rates)
                        df['time'] = pd.to_datetime(df['time'], unit='s')
                        logging.info(f"[{function_name}] Datos obtenidos para {symbol}:\n{df.tail(1)}")
                except Exception as e:
                    logging.error(f"[{function_name}] Error inesperado al obtener datos: {e}")
                time.sleep(interval)
        else:
            logging.info(f"[{function_name}] Obteniendo {limit} datos de {symbol} en timeframe {timeframe}...")
            rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, limit)
            if rates is None:
                logging.error(f"[{function_name}] Error al obtener datos para {symbol}: {mt5.last_error()}")
                return None
            
            df = pd.DataFrame(rates)
            df['time'] = pd.to_datetime(df['time'], unit='s')
            logging.info(f"[{function_name}] Datos obtenidos correctamente para {symbol}:\n{df}")
            return df
    finally:
        mt5.shutdown()
        logging.info(f"[{function_name}] MetaTrader 5 cerrado correctamente.")






















#  Preparar los datos
import pandas as pd
import logging
import sys
from sklearn.preprocessing import MinMaxScaler

# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def prepare_data(data): 
    function_name = sys._getframe().f_code.co_name  # Obtener el nombre de la funci贸n
    logging.info(f"[{function_name}] Iniciando preprocesamiento de datos...")

    # Creando escaladores
    scaler_x = MinMaxScaler()
    scaler_y = MinMaxScaler()
    logging.info(f"[{function_name}] Creando escaladores MinMaxScaler para X e Y.")

    # Creando DataFrame con nombres de columnas
    df = pd.DataFrame(data, columns=[f'feature_{i}' for i in range(data.shape[1])])
    logging.info(f"[{function_name}] Creado DataFrame con {df.shape[0]} filas y {df.shape[1]} columnas.")

    # Separando variables independientes (X) y dependientes (y)
    X = df.drop(columns=['feature_0'])
    y = df[['feature_0']].values  
    logging.info(f"[{function_name}] Separadas variables X (shape={X.shape}) e Y (shape={y.shape}).")

    # Aplicando normalizaci贸n MinMaxScaler
    X_scaled = pd.DataFrame(scaler_x.fit_transform(X), columns=X.columns)
    y_scaled = scaler_y.fit_transform(y).flatten()
    logging.info(f"[{function_name}] Datos escalados con MinMaxScaler.")

    # Reconstruyendo DataFrame con los datos escalados
    df_scaled = pd.concat([pd.DataFrame(y_scaled, columns=['feature_0']), X_scaled], axis=1)
    logging.info(f"[{function_name}] DataFrame escalado listo con {df_scaled.shape[0]} filas y {df_scaled.shape[1]} columnas.")

    return df_scaled, scaler_x, scaler_y

















#  Modelo LSTM optimizado

# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def create_model(timesteps, features):
    function_name = sys._getframe().f_code.co_name  # Obtener el nombre de la funci贸n
    logging.info(f"[{function_name}] Iniciando la creaci贸n del modelo con timesteps={timesteps}, features={features}...")

    model = Sequential([
        Input(shape=(timesteps, features)),
        LSTM(64, return_sequences=True),
        Dropout(0.2),
        LSTM(32, return_sequences=False),
        Dropout(0.2),
        Dense(16, activation='relu'),
        Dense(8, activation='relu'),
        Dense(1, activation='linear')
    ])
    logging.info(f"[{function_name}] Modelo creado con estructura LSTM.")

    model.compile(optimizer=Adam(learning_rate=0.001), loss='mae', metrics=['mae'])
    logging.info(f"[{function_name}] Modelo compilado con Adam(lr=0.001), p茅rdida='mae' y m茅trica='mae'.")

    return model















#  Entrenar modelo
# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def train_model(model, X_train, y_train, epochs=200, batch_size=64):
    function_name = sys._getframe().f_code.co_name  # Obtener el nombre de la funci贸n
    logging.info(f"[{function_name}] Iniciando entrenamiento del modelo...")
    logging.info(f"[{function_name}] Par谩metros: epochs={epochs}, batch_size={batch_size}, validation_split=0.2")

    early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
    logging.info(f"[{function_name}] EarlyStopping configurado (monitor='val_loss', patience=10).")

    history = model.fit(
        X_train, y_train, 
        epochs=epochs, batch_size=batch_size, 
        verbose=1, validation_split=0.2, 
        callbacks=[early_stopping]
    )
    
    logging.info(f"[{function_name}] Entrenamiento finalizado.")
    return history



















#  Predecir valores futuros
# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def predict_future(model, X):
    function_name = sys._getframe().f_code.co_name  # Obtener el nombre de la funci贸n
    logging.info(f"[{function_name}] Iniciando predicci贸n con {X.shape[0]} muestras.")

    predictions = model.predict(X)

    logging.info(f"[{function_name}] Predicci贸n completada. Generadas {predictions.shape[0]} predicciones.")
    return predictions























#  Calcular RSI correctamente
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'

# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

#  Calcular ATR manualmente
def calculate_atr(df, high_col, low_col, close_col, window=14):
    function_name = sys._getframe().f_code.co_name
    logging.info(f"[{function_name}] Calculando ATR con ventana de {window} per铆odos.")

    df['H-L'] = df[high_col] - df[low_col]
    df['H-C'] = abs(df[high_col] - df[close_col].shift(1))
    df['L-C'] = abs(df[low_col] - df[close_col].shift(1))
    df['TR'] = df[['H-L', 'H-C', 'L-C']].max(axis=1)
    df['ATR'] = df['TR'].rolling(window=window).mean()
    
    df.drop(columns=['H-L', 'H-C', 'L-C', 'TR'], inplace=True)

    logging.info(f"[{function_name}] ATR calculado correctamente.")
    return df

#  Calcular ADX manualmente
def calculate_adx(df, high_col, low_col, close_col, window=14):
    function_name = sys._getframe().f_code.co_name
    logging.info(f"[{function_name}] Calculando ADX con ventana de {window} per铆odos.")

    df['+DM'] = df[high_col].diff()
    df['-DM'] = df[low_col].diff()
    df['+DM'] = np.where((df['+DM'] > df['-DM']) & (df['+DM'] > 0), df['+DM'], 0)
    df['-DM'] = np.where((df['-DM'] > df['+DM']) & (df['-DM'] > 0), df['-DM'], 0)

    df = calculate_atr(df, high_col, low_col, close_col, window)
    
    df['+DI'] = 100 * (df['+DM'].rolling(window=window).mean() / df['ATR'])
    df['-DI'] = 100 * (df['-DM'].rolling(window=window).mean() / df['ATR'])
    df['DX'] = 100 * abs(df['+DI'] - df['-DI']) / (df['+DI'] + df['-DI'])
    df['ADX'] = df['DX'].rolling(window=window).mean()
    
    df.drop(columns=['+DM', '-DM', '+DI', '-DI', 'DX'], inplace=True)

    logging.info(f"[{function_name}] ADX calculado correctamente.")
    return df

#  Calcular RSI manualmente
def calculate_rsi(df, column, window=14):
    function_name = sys._getframe().f_code.co_name
    logging.info(f"[{function_name}] Calculando RSI con ventana de {window} per铆odos.")

    delta = df[column].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))
    df['RSI'].fillna(50, inplace=True)

    logging.info(f"[{function_name}] RSI calculado correctamente.")
    return df

#  Generar se帽ales de compra y venta
def generate_signals(df):
    function_name = sys._getframe().f_code.co_name
    logging.info(f"[{function_name}] Generando se帽ales de compra y venta.")

    df['SMA_5'] = df['AI_Indicator'].rolling(window=5).mean()
    df['SMA_10'] = df['AI_Indicator'].rolling(window=10).mean()
    df['Momentum'] = df['AI_Indicator'].diff()

    df.dropna(inplace=True)

    df['Buy_Signal'] = (df['SMA_5'] > df['SMA_10']) & (df['RSI'] < 30) & (df['Momentum'] > 0) & (df['ADX'] > 20)
    df['Sell_Signal'] = (df['SMA_5'] < df['SMA_10']) & (df['RSI'] > 70) & (df['Momentum'] < 0) & (df['ADX'] > 20)

    logging.info(f"[{function_name}] Se帽ales generadas correctamente.")
    return df























#  Modelo LSTM optimizado con tuning de hiperpar谩metros
# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

#  Crear modelo de optimizaci贸n con Optuna
def create_model(trial, timesteps, features):
    function_name = sys._getframe().f_code.co_name
    logging.info(f"[{function_name}] Creando modelo con {timesteps} timesteps y {features} features.")

    units1 = trial.suggest_int('units1', 32, 128)
    units2 = trial.suggest_int('units2', 16, 64)
    dropout_rate = trial.suggest_float('dropout_rate', 0.1, 0.5)
    learning_rate = trial.suggest_float('learning_rate', 1e-4, 1e-2)

    logging.info(f"[{function_name}] Hiperpar谩metros sugeridos - Units1: {units1}, Units2: {units2}, Dropout: {dropout_rate}, Learning Rate: {learning_rate}")

    model = Sequential([
        Input(shape=(timesteps, features)),
        LSTM(units1, return_sequences=True),
        Dropout(dropout_rate),
        LSTM(units2, return_sequences=False),
        Dropout(dropout_rate),
        Dense(16, activation='relu'),
        Dense(8, activation='relu'),
        Dense(1, activation='linear')
    ])

    model.compile(optimizer=Adam(learning_rate=learning_rate), loss='mae', metrics=['mae'])

    logging.info(f"[{function_name}] Modelo compilado correctamente.")
    return model



















#  Entrenar modelo con validaci贸n cruzada
# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

#  Funci贸n objetivo para Optuna
def objective(trial):
    function_name = sys._getframe().f_code.co_name
    logging.info(f"[{function_name}] Iniciando optimizaci贸n de hiperpar谩metros.")

    global ventanas, etiquetas, window_size

    tscv = TimeSeriesSplit(n_splits=5)
    mae_scores = []

    logging.info(f"[{function_name}] Iniciando validaci贸n cruzada con {tscv.get_n_splits()} splits.")

    for fold, (train_idx, val_idx) in enumerate(tscv.split(ventanas), start=1):
        logging.info(f"[{function_name}] Procesando fold {fold}...")

        X_train, X_val = ventanas[train_idx], ventanas[val_idx]
        y_train, y_val = etiquetas[train_idx], etiquetas[val_idx]

        logging.info(f"[{function_name}] Creando modelo para el fold {fold}.")
        model = create_model(trial, window_size, X_train.shape[2])

        early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

        logging.info(f"[{function_name}] Entrenando modelo en el fold {fold}...")
        model.fit(X_train, y_train, epochs=50, batch_size=64, validation_data=(X_val, y_val),
                  verbose=0, callbacks=[early_stopping])

        logging.info(f"[{function_name}] Generando predicciones en el fold {fold}.")
        y_pred = model.predict(X_val).flatten()
        mae = mean_absolute_error(y_val, y_pred)
        mae_scores.append(mae)

        logging.info(f"[{function_name}] MAE para el fold {fold}: {mae:.4f}")

    mean_mae = np.mean(mae_scores)
    logging.info(f"[{function_name}] Optimizaci贸n completada. MAE promedio: {mean_mae:.4f}")

    return mean_mae





















# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

#  Simulaci贸n de datos
logging.info("[Simulaci贸n] Configurando semilla aleatoria y generando datos.")
np.random.seed(42)
data = np.random.rand(10000, 5)
data = (data - np.mean(data, axis=0)) / np.std(data, axis=0)

#  Calcular indicadores y preparar datos
logging.info("[Indicadores] Creando DataFrame y calculando RSI, ATR y ADX.")
df = pd.DataFrame(data, columns=['Open', 'High', 'Low', 'Close', 'Volume'])
df = calculate_rsi(df, column='Close', window=14)
df = calculate_atr(df, high_col='High', low_col='Low', close_col='Close', window=14)
df = calculate_adx(df, high_col='High', low_col='Low', close_col='Close', window=14)

window_size = 50
future_offset = 50
tp = 0.0001

#  Preparar datos para LSTM con etiquetas
logging.info("[Preparaci贸n] Creando ventanas de datos y etiquetas para entrenamiento.")
ventanas = []
etiquetas = []

for i in range(len(df) - window_size - future_offset):
    ventanas.append(df.iloc[i:i + window_size].values)
    precio_actual = df.iloc[i + window_size - 1]['Close']
    precio_futuro = df.iloc[i + window_size + future_offset - 1]['Close']
    etiquetas.append(1 if abs(precio_futuro - precio_actual) >= tp else 0)

ventanas = np.array(ventanas, dtype=np.float32)
etiquetas = np.array(etiquetas, dtype=np.float32)

logging.info(f"[Preparaci贸n] Datos listos: {ventanas.shape[0]} muestras, {ventanas.shape[1]} timesteps, {ventanas.shape[2]} features.")

#  Optimizaci贸n de hiperpar谩metros con Optuna
logging.info("[Optuna] Iniciando optimizaci贸n de hiperpar谩metros.")
study = optuna.create_study(direction='minimize')
study.optimize(objective, n_trials=20)

#  Entrenar modelo final con los mejores hiperpar谩metros
logging.info("[Entrenamiento] Configurando modelo con los mejores hiperpar谩metros encontrados.")
best_params = study.best_params
model = create_model(optuna.trial.FixedTrial(best_params), window_size, ventanas.shape[2])

train_size = int(0.8 * len(ventanas))
ventanas_train, etiquetas_train = ventanas[:train_size], etiquetas[:train_size]
ventanas_test, etiquetas_test = ventanas[train_size:], etiquetas[train_size:]

logging.info(f"[Entrenamiento] Datos divididos: {len(ventanas_train)} train, {len(ventanas_test)} test.")

early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
logging.info("[Entrenamiento] Iniciando entrenamiento del modelo.")
model.fit(ventanas_train, etiquetas_train, epochs=50, batch_size=64, validation_data=(ventanas_test, etiquetas_test),
          callbacks=[early_stopping])

logging.info("[Finalizado] Entrenamiento completo.") 



























# Predicci贸n en tiempo real
symbols = [
    "AUDCADm", "AUDCHFm", "AUDDKKm", "AUDJPYm", "AUDMXNm", "AUDNOKm", "AUDNZDm", "AUDPLNm",
    "AUDSEKm", "AUDSGDm", "AUDUSDm", "AUDZARm", "AUS200m", "CADCHFm", "CADJPYm", "CADMXNm",
    "CADNOKm", "CADPLNm", "CHFDKKm", "CHFJPYm", "CHFMXNm", "CHFNOKm", "CHFPLNm", "CHFSEKm",
    "CHFSGDm", "CHFZARm", "DKKJPYm", "DKKPLNm", "DKKSGDm", "DKKZARm", "EURAUDm", "EURCADm",
    "EURCHFm", "EURDKKm", "EURGBPm", "EURJPYm", "EURMXNm", "EURNOKm", "EURNZDm", "EURPLNm",
    "EURSEKm", "EURSGDm", "EURUSDm", "EURZARm", "GBPCADm", "GBPCHFm", "GBPDKKm", "GBPILSm",
    "GBPJPYm", "GBPMXNm", "GBPNOKm", "GBPNZDm", "GBPPLNm", "GBPSEKm", "GBPSGDm", "GBPUSDm",
    "GBPZARm", "NOKDKKm", "NOKJPYm", "NOKSEKm", "NZDCADm", "NZDCHFm", "NZDDKKm", "NZDJPYm",
    "NZDMXNm", "NZDNOKm", "NZDPLNm", "NZDSEKm", "NZDSGDm", "NZDUSDm", "NZDZARm", "PLNDKKm",
    "PLNJPYm", "PLNSEKm", "SEKDKKm", "SEKJPYm", "SGDHKDm", "SGDJPYm", "USDCADm", "USDCHFm",
    "USDCNHm", "USDDKKm", "USDHKDm", "USDILSm", "USDJPYm", "USDMXNm", "USDNOKm", "USDPLNm",
    "USDSEKm", "USDSGDm", "USDTHBm", "USDZARm", "XAGAUDm", "XAGEURm", "XAGGBPm", "XAGUSDm",
    "XALUSDm", "XAUEURm", "XAUGBPm", "XAUUSDm", "XCUUSDm", "XNGUSDm", "XNIUSDm", "XPBUSDm",
    "XPDUSDm", "XPTUSDm", "XZNUSDm", "ZARJPYm"
]












# Configuraci贸n del logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def load_trained_model():
    """Carga un modelo entrenado desde un archivo .h5"""
    logging.info("[load_trained_model] Intentando cargar el modelo entrenado.")

    try:
        model = tf.keras.models.load_model("modelo_final.h5")
        logging.info("[load_trained_model] Modelo cargado exitosamente.")
        return model
    except Exception as e:
        logging.error(f"[load_trained_model] Error al cargar el modelo: {e}")
        return None
    














#========================================== MAIN =======================================================================#






#  Funci贸n principal
def main():
    timeframe = mt5.TIMEFRAME_M1

    # Inicializar MetaTrader 5 solo una vez
    if not mt5.initialize():
        logging.error("Error al inicializar MetaTrader 5.")
        return

    model = load_trained_model()
    if model is None:
        return

    for symbol in symbols:
        logging.info(f"Iniciando predicci贸n para {symbol}...")

        market_data = fetch_market_data(symbol, timeframe, limit=50)
        if market_data is None or len(market_data) < 50:
            logging.warning(f"Datos insuficientes para {symbol}. Saltando...")
            continue

        # Preparar datos para el modelo
        recent_data = market_data.iloc[-50:][['close']].values.reshape(1, 50, -1)

        # Realizar predicci贸n
        try:
            prediction = model.predict(recent_data)[0][0]
        except Exception as e:
            logging.error(f"Error en la predicci贸n para {symbol}: {e}")
            continue

        current_price = market_data.iloc[-1]['close']
        logging.info(f"Predicci贸n en 5s para {symbol}: {prediction}, Precio actual: {current_price}")

        # Determinar se帽al de compra o venta
        if prediction > current_price:
            logging.info(f"Se帽al de COMPRA para {symbol}")
        elif prediction < current_price:
            logging.info(f"Se帽al de VENTA para {symbol}")
        else:
            logging.info(f"No hay se帽al clara para {symbol}")

        # Esperar 5 segundos y obtener el precio real
        time.sleep(5)
        actual_data = fetch_market_data(symbol, timeframe, limit=1)
        if actual_data is None or len(actual_data) == 0:
            logging.warning(f"No se pudo obtener el precio real para {symbol}")
            continue

        actual_price = actual_data.iloc[-1]['close']
        logging.info(f"Precio real despu茅s de 5s para {symbol}: {actual_price}")

        # Evaluar precisi贸n de la predicci贸n
        error = abs(prediction - actual_price)
        logging.info(f"Error de predicci贸n: {error:.6f}")

    # Apagar MetaTrader 5 al finalizar
    mt5.shutdown()
    logging.info("Ejecuci贸n completada.")

if __name__ == "__main__":
    main()
